# Optimized Word Search Using BST Variants

Second trial work of the module "Algorithmics and dynamic data structures".\
This project explores the optimization of word search operations through customized Binary Search Tree (BST) structures. Implemented using the educational **Z** programming language with the Khawarizm II+ AFE (2023) - Copyright Â© Pr D.E ZEGOUR 2023 - IDE, and translated to C for performance and result enhancement, it also employs Python for data visualization and statistical analysis.

<div align="center">
  <img alt="GitHub Repo stars" src="https://img.shields.io/github/stars/kalis26/Optimized-Word-Search-Using-BST-Variants">
  <img alt="GitHub forks" src="https://img.shields.io/github/forks/kalis26/Optimized-Word-Search-Using-BST-Variants">
  <img alt="GitHub Issues or Pull Requests" src="https://img.shields.io/github/issues/kalis26/Optimized-Word-Search-Using-BST-Variants?color=orange">
  <object data="https://img.shields.io/github/license/kalis26/Optimized-Word-Search-Using-BST-Variants"></object>
</div>

![GitHub License](https://img.shields.io/github/license/kalis26/Optimized-Word-Search-Using-BST-Variants?link=https%3A%2F%2Fgithub.com%2Fkalis26%2FOptimized-Word-Search-Using-BST-Variants%2Fblob%2Fmain%2FLICENSE)

## Objective
- The core idea is to accelerate word searches by distributing them across a triplet of BSTs (BST1, BST2, BST3) based on the initial character of each word. Each tree uses specific rotation strategies to optimize node placement:

  1. BST1 prioritizes words starting with 'Y', 'Z', or 'a', rotating them to the root.

  2. BST2 places such words mid-path.

  3. BST3 handles all other words with root rotations.
 
## Features
- Word insertion and search algorithms tailored to letter-based routing.
- Range search implementation across BST variants.
- Automatic translation of logic from Z to C.
- Simulation modules to compare standard BSTs vs. optimized BST triplet.
- Performance tracking for both successful and failed searches.
- Graphical visualization of search efficiency using Python.

## Documentation
- A detailed report accompanies the project, covering:

  * Implementation methodology in Z and C.

  * Performance analysis with tables and graphs.

  * Conclusions based on empirical data.
 
- To know more about the project, you can access the instructions folder.

## System Requirements
- For the Z part (.alg):

  * [Khawarizm II+ AFE (2023)](https://zegour.esi.dz/Developpement/Seriez/khawarizm_ii_afe.htm)
 
- For the C part:

  * Windows terminal
  * Standard C libraries
 
## How to run ?

- For the Z part (.alg):

  * Open the **.alg** file in the Khawarizm IDE and execute it.
  *  ***Note:*** Khawarizm is mainly for editing and writing algorithms, it is not designed for high-quality result presentation.

- For the C part:

  * First, you need to get the full path of the folder the executable is in.
  * Once you have it, opend the Windows terminal "cmd" (not as administrator) and execute the following commands:
 
```
cd "insert_path_here"
```
```
TP2.exe
```
 
## Insights & Recommandations
  
* The majority of the practical work was done on the Khawarizm II+ AFE IDE using the Z language. The rest of the work was completed on Visual Studio Code using the C language. You can also use CodeBlocks and there won't be any compiling errors, even if there are, I uploaded in this folder the compiled "**TP2.exe**" that you can execute.

* To make changes or execute the "**TP2.alg**" file, which contains the Khawarizm part of the practical work, you will need the IDE I mentioned earlier that can be found here: https://zegour.esi.dz/

* The report on the practical work was done using the LaTeX language, you can find it in the folder. The graphs and tables used in it were created using a Python script that you can find in the folder as well. It is based on "**.csv**" files generated by the C program, I removed the lines that generate the files but you can easily rewrite them.
